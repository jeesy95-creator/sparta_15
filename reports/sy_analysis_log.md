## 20260127 분석 로그 
Bellabeat Fitbit 데이터 분석 인사이트

1. 고강도 활동 시간이 칼로리 소모에 가장 큰 영향을 준다  
칼로리 그룹이 높아질수록 VeryActiveMinutes가 가장 큰 폭으로 증가하였다.  
반면 LightlyActiveMinutes는 그룹 간 차이가 크지 않았다.  
이는 칼로리 소모 증가가 가벼운 활동의 누적보다는 짧고 강도 높은 활동 증가와 더 밀접하게 연결되어 있음을 의미한다.  
Bellabeat은 장시간 운동을 강조하기보다 10분 내외의 짧고 강도 있는 활동을 장려하는 방향이 효과적이다.

2. 저칼로리 그룹은 좌식 시간이 매우 길다  
0~1000 kcal 그룹에서 SedentaryMinutes 평균이 가장 높게 나타났다.  
이는 Bellabeat의 핵심 타겟이 이미 활발히 운동하는 사용자가 아니라 일상에서 대부분의 시간을 앉아서 보내는 사용자임을 시사한다.  
따라서 Bellabeat은 운동 앱이기보다는 생활 습관 개선 중심의 헬스케어 앱으로 포지셔닝하는 것이 적합하다.

3. 고칼로리 그룹은 다양한 강도의 활동을 조합한다  
고칼로리 그룹에서는 VeryActiveMinutes, FairlyActiveMinutes, LightlyActiveMinutes가 모두 일정 수준 이상 존재하였다.  
이는 고활동 사용자가 한 가지 유형의 운동만 하는 것이 아니라 여러 강도의 활동을 조합해 수행함을 의미한다.  
Bellabeat은 단일 목표보다는 활동 강도별 목표를 함께 제시하는 방식이 효과적이다.

4. 사용자 간 활동 수준 편차가 매우 크다  
사용자별 평균 걸음 수, 거리, 칼로리 소모량의 분산이 크게 나타났다.  
모든 사용자에게 동일한 목표를 제시하면 동기부여 효과가 떨어질 가능성이 높다.  
Bellabeat은 개인의 과거 기록을 기준으로 한 개인화 목표 설정 방식을 적용할 필요가 있다.

5. 거리보다 시간 기반 지표가 행동 이해에 더 직관적이다  
km로 변환된 거리 변수보다 TotalActiveMinutes와 같은 시간 기반 지표에서 칼로리 그룹별 차이가 더 뚜렷하게 나타났다.  
이는 사용자가 자신의 활동 수준을 이해할 때 이동거리보다 활동 시간이 더 직관적인 지표임을 의미한다.  
Bellabeat 앱의 핵심 지표는 거리 중심이 아닌 활동 시간 중심으로 설계하는 것이 바람직하다.

6. 칼로리 효율 지표는 최소 활동 기준 이후에 제공하는 것이 적절하다  
0.5 km 미만의 짧은 이동 구간에서는 CaloriesPerKm 값의 변동성이 매우 컸다.  
이는 매우 짧은 활동 구간에서는 칼로리 효율 지표의 신뢰도가 낮다는 것을 의미한다.  
따라서 Bellabeat은 일정 시간 또는 일정 거리 이상의 활동이 발생한 경우에만 칼로리 효율 지표를 제공하는 것이 적절하다.

## 20260127 분석 로그 

# 데이터 분석 로그: 칼로리 그룹별 파생 변수 이상치 문제 해결

**분석 날짜**: 2026년 1월 27일  
**분석자**: Soyun  
**데이터**: dailyActivity_merged_fin_sum.csv

---

## 🔍 1. 문제 발견

### 1.1 초기 증상
칼로리 그룹별 파생 변수 평균 계산 시 **비논리적인 패턴** 발견:

| 칼로리 그룹 | 고강도 활동 비율 | 평균 속도 (km/h) | 평균 페이스 (min/km) |
|------------|----------------|-----------------|-------------------|
| 500-1000   | 0.064 (6.4%)   | 2.601           | 24.256           |
| 1000-1500  | 0.010 (1.0%)   | 1.598           | 42.281           |
| 1500-2000  | 0.028 (2.8%)   | 1.711           | 37.996           |
| 2000-2500  | 0.038 (3.8%)   | 1.827           | 35.299           |
| 2500 이상  | 0.036 (3.6%)   | 2.155           | 29.532           |

### 1.2 문제점 식별
1. **500-1000 그룹**: 
   - 칼로리가 낮은데도 고강도 비율이 6.4%로 다른 그룹보다 **높음** ❌
   - 속도가 2.601 km/h로 1000-1500, 1500-2000보다 **빠름** ❌

2. **1000-1500 그룹**:
   - 고강도 활동 비율이 1.0%로 **가장 낮음** ❌
   - 속도가 1.598 km/h로 **가장 느림** ❌
   - 페이스가 42.281 min/km로 **가장 느림** ❌

3. **논리적 모순**:
   - 칼로리 소모가 적은 그룹이 더 빠르고 강하게 움직인다는 것은 비논리적
   - 정상적이라면: 칼로리 ↑ → 활동량 ↑ → 속도 ↑ → 고강도 비율 ↑

---

## 2. 원인 분석

### 2.1 데이터 탐색

#### 칼로리 그룹별 샘플 수 확인
```
500 이하:       13개
500-1000:       5개   ⚠️ 매우 적음
1000-1500:    129개
1500-2000:    396개
2000-2500:    350개
2500 이상:     480개
```

#### 500-1000 그룹 상세 데이터 (n=5)
| Calories | TotalSteps | TotalDistance_km | TotalActiveMinutes | VeryActiveMinutes |
|----------|-----------|------------------|-------------------|------------------|
| 665      | 0         | 0.00             | 0                 | 0                |
| 741      | 3121      | 2.04             | 62                | 8                |
| 735      | 0         | 0.00             | 20                | 20               |
| 787      | 14        | 0.01             | 1                 | 0                |
| 928      | 3587      | 2.37             | 113               | 0                |

**문제점**:
- 5개 샘플 중 2개(40%)가 거리=0, 걸음수=0
- 3개(60%)가 VeryActiveMinutes=0
- **샘플 수가 너무 적어 통계적으로 의미 없음**

### 2.2 1000-1500 그룹 분석 (n=129)

#### VeryActiveMinutes 분포
```
VeryActiveMinutes = 0인 데이터: 117개 (90.7%)
평균: 1.2분
중간값: 0분
```

#### TotalDistance = 0 또는 TotalSteps = 0
```
TotalDistance = 0: 30개 (23.3%)
TotalSteps = 0: 28개 (21.7%)
```

**분석**:
- 1000-1500 칼로리 그룹은 대부분 **저활동** 사용자
- 거의 움직이지 않고 **기초대사량**으로만 칼로리 소모
- 파생 변수(속도, 페이스 등) 계산 시 **분모가 0에 가까워** 의미 없는 값 생성

### 2.3 근본 원인
1. **샘플 수 부족**: 500-1000 그룹은 5개로 통계적 신뢰도 없음
2. **저활동 데이터**: 1000-1500 그룹은 90% 이상이 고강도 활동=0
3. **파생 변수 왜곡**: 활동량이 거의 없는 데이터로 속도/페이스 계산 시 이상치 발생

---

## 💡 3. 해결 방법

### 3.1 접근 방식
**Option 1**: 최소 활동량 필터 추가
```python
df_filtered = df[
    (df['TotalSteps'] > 1000) & 
    (df['TotalDistance_km'] > 0.5) &
    (df['TotalActiveMinutes'] > 30)
]
```

**Option 2**: 샘플 수가 적은 그룹 제외 (채택 ✅)
- 500-1000 그룹 제외 (n=5, 통계적으로 무의미)
- 500 이하 그룹도 제외 (n=13, 69%가 거리=0)

### 3.2 구현: 칼로리 그룹 재정의

#### Before (6개 그룹)
```python
bins = [0, 500, 1000, 1500, 2000, 2500, float('inf')]
labels = ['500 이하', '500-1000', '1000-1500', '1500-2000', '2000-2500', '2500 이상']
```

#### After (4개 그룹) ✅
```python
bins = [1000, 1500, 2000, 2500, float('inf')]
labels = ['1000-1500', '1500-2000', '2000-2500', '2500 이상']
```

### 3.3 코드 수정 위치

**문제가 된 부분**: 이상치 제거 후 기존 CalorieGroup 컬럼 유지
```python
# 잘못된 방법
actcp_d_clean = remove_outliers_iqr(actcp_d, outlier_cols)
# actcp_d에 이미 5개 그룹의 CalorieGroup이 포함되어 있음
print(actcp_d_clean['CalorieGroup'].value_counts())  # 여전히 5개 그룹
```

**수정된 코드**:
```python
# 1. 이상치 제거
actcp_d_clean = remove_outliers_iqr(actcp_d, outlier_cols)

# 2. 기존 CalorieGroup 삭제
if 'CalorieGroup' in actcp_d_clean.columns:
    actcp_d_clean = actcp_d_clean.drop('CalorieGroup', axis=1)

# 3. 4개 그룹으로 재정의
bins = [1000, 1500, 2000, 2500, float('inf')]
labels = ['1000-1500', '1500-2000', '2000-2500', '2500 이상']
actcp_d_clean['CalorieGroup'] = pd.cut(
    actcp_d_clean['Calories'], 
    bins=bins, 
    labels=labels, 
    right=False
)
```

---

## ✅ 4. 수정 결과

### 4.1 수정 후 칼로리 그룹별 파생 변수 평균

| 칼로리 그룹 | TotalActiveMinutes | AvgSpeed_kmh | AvgPace_min_per_km | AvgStride_m | VeryActiveRatio | LightActiveRatio | CaloriesPerKm |
|------------|-------------------|--------------|-------------------|-------------|----------------|-----------------|---------------|
| 1000-1500  | 154.056          | 1.593        | 42.272            | 1.054       | 0.010          | 0.982           | 427.106       |
| 1500-2000  | 245.166          | 1.711        | 37.996            | 1.069       | 0.028          | 0.945           | 307.220       |
| 2000-2500  | 286.310          | 1.821        | 35.462            | 1.100       | 0.038          | 0.933           | 313.054       |
| 2500 이상  | 265.560          | 2.155        | 29.532            | 1.201       | 0.036          | 0.925           | 343.571       |

### 4.2 논리적 타당성 검증 ✅

#### ✅ 활동 시간 증가 패턴
- 1000-1500: 154분
- 1500-2000: 245분 (+59%)
- 2000-2500: 286분 (+17%)

#### ✅ 속도 증가 패턴
- 1000-1500: 1.593 km/h
- 1500-2000: 1.711 km/h (+7.4%)
- 2000-2500: 1.821 km/h (+6.4%)
- 2500 이상: 2.155 km/h (+18.3%)

#### ✅ 페이스 개선 패턴 (숫자가 작을수록 빠름)
- 1000-1500: 42.272 min/km
- 1500-2000: 37.996 min/km (10% 빨라짐)
- 2000-2500: 35.462 min/km (7% 빨라짐)
- 2500 이상: 29.532 min/km (17% 빨라짐)

#### ✅ 고강도 활동 비율
- 1000-1500: 1.0%
- 1500-2000: 2.8% (2.8배 증가)
- 2000-2500: 3.8% (1.4배 증가)
- 2500 이상: 3.6%

#### ✅ 평균 보폭
- 1000-1500: 1.054 m
- 1500-2000: 1.069 m
- 2000-2500: 1.100 m
- 2500 이상: 1.201 m (가장 김)

### 4.3 결론
**칼로리 소모량이 높을수록:**
- ✅ 활동 시간이 길고
- ✅ 이동 속도가 빠르고
- ✅ 페이스가 빠르고
- ✅ 보폭이 길고
- ✅ 고강도 활동 비율이 높다

**→ 논리적으로 타당한 패턴!**

---

## 5. 학습 포인트 (Lessons Learned)

### 5.1 샘플 수의 중요성
- **통계적 신뢰도**: 최소 30개 이상의 샘플 필요
- **n=5는 평균을 내기에 너무 적음**: 이상치 1-2개가 전체 평균을 왜곡

### 5.2 데이터 전처리 순서
올바른 순서:
1. 파생 변수 생성
2. NaN 제거
3. 이상치 제거
4. **그룹핑 변수 재정의** ⭐ (중요!)
5. 그룹별 통계 계산

### 5.3 데이터 품질 확인
그룹별 분석 전에 확인할 사항:
- [ ] 각 그룹의 샘플 수
- [ ] 0값이나 결측치 비율
- [ ] 이상치 분포
- [ ] 그룹 간 중복 여부

### 5.4 논리적 검증의 중요성
- **"이 결과가 말이 되는가?"** 항상 자문
- 도메인 지식(운동 생리학)을 활용한 검증
- 예상과 다른 결과는 반드시 원인 탐색

---

## 6. 향후 개선 방향

### 6.1 추가 필터링 고려사항
```python
# 최소 활동량 기준 추가
df_active = df[
    (df['TotalSteps'] > 1000) &      # 최소 걸음수
    (df['TotalDistance_km'] > 0.5) &  # 최소 이동거리
    (df['TotalActiveMinutes'] > 30)   # 최소 활동시간
]
```

### 6.2 1000-1500 그룹 재검토
- 현재: 90.7%가 VeryActiveMinutes=0
- 고려사항: 이 그룹도 제외하거나 별도 분석 필요할 수 있음
- 대안: "저활동 그룹"으로 재분류

### 6.3 통계적 검정
- 그룹 간 차이가 통계적으로 유의한지 검증 (ANOVA, t-test)
- 효과 크기(Effect Size) 계산

---

## 7. 최종 권장사항

### 7.1 분석에 사용할 데이터
✅ **4개 칼로리 그룹 (1000 이상)**
- 1000-1500 (n=129)
- 1500-2000 (n=396)
- 2000-2500 (n=350)
- 2500 이상 (n=480)

### 7.2 제외한 데이터
❌ **500-1000 그룹** (n=5): 샘플 수 부족
❌ **500 이하 그룹** (n=13): 69%가 활동량=0

### 7.3 해석 시 주의사항
- 1000-1500 그룹은 "저활동 그룹"으로 해석
- 이 그룹의 속도/페이스는 참고용으로만 활용
- 주요 분석은 1500 이상 그룹에 집중

---

## 📊 부록: 코드 변경 이력

### A.1 초기 코드 (문제 있음)
```python
# act 데이터에 칼로리 그룹 정의 (6개 그룹)
bins = [0, 500, 1000, 1500, 2000, 2500, float('inf')]
labels = ['500 이하', '500-1000', '1000-1500', '1500-2000', '2000-2500', '2500 이상']
act['CalorieGroup'] = pd.cut(act['Calories'], bins=bins, labels=labels, right=False)

# ... 중간 처리 ...

# 이상치 제거
actcp_d_clean = remove_outliers_iqr(actcp_d, outlier_cols)

# 그룹별 평균 계산 (문제: 여전히 6개 그룹)
calorie_group_derived = actcp_d_clean.groupby('CalorieGroup', observed=True)[derived_cols].mean()
```

### A.2 수정된 코드 (해결됨)
```python
# act 데이터에 칼로리 그룹 정의 (4개 그룹)
bins = [1000, 1500, 2000, 2500, float('inf')]
labels = ['1000-1500', '1500-2000', '2000-2500', '2500 이상']
act['CalorieGroup'] = pd.cut(act['Calories'], bins=bins, labels=labels, right=False)

# ... 파생 변수 생성 ...

# 이상치 제거
actcp_d_clean = remove_outliers_iqr(actcp_d, outlier_cols)

# 칼로리 그룹 재정의 (중요!)
if 'CalorieGroup' in actcp_d_clean.columns:
    actcp_d_clean = actcp_d_clean.drop('CalorieGroup', axis=1)

actcp_d_clean['CalorieGroup'] = pd.cut(
    actcp_d_clean['Calories'], 
    bins=bins, 
    labels=labels, 
    right=False
)

# 그룹별 평균 계산 (해결: 4개 그룹)
calorie_group_derived = actcp_d_clean.groupby('CalorieGroup', observed=True)[derived_cols].mean()
```

수동 입력 데이터 고려 필요

분석 결과:
1. 수동 입력 비율이 매우 낮음

전체의 **3.9%**만 수동 입력 사용
1000-1500 그룹: 0.8% (129개 중 단 1개)
1500-2000 그룹: 0.0% (전혀 없음)

2. 수동 입력 거리도 미미함

1000-1500 그룹 평균: 0.012 km (거의 0)
2500 이상 그룹만 평균 0.311 km로 의미 있는 수준

3. TotalDistance ≈ TrackerDistance

평균 차이: 0.0277 km (거의 동일)
대부분의 데이터가 자동 추적에만 의존

결론:
수동 입력 데이터는 문제가 아닙니다!
1000-1500 그룹의 이상한 패턴은:

✅ 수동 입력 때문이 아니라
✅ 실제로 거의 움직이지 않는 사람들이라서
✅ 기초대사량으로만 1000-1500 칼로리 소모

따라서 현재 분석 방법(500-1000 그룹 제외, 4개 그룹 사용) 적용하기로 함 

